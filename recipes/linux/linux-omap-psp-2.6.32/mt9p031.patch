diff --git git/arch/arm/mach-omap2/Makefile git/arch/arm/mach-omap2/Makefile
index a49d436..5a5c312 100644
--- git/arch/arm/mach-omap2/Makefile
+++ git/arch/arm/mach-omap2/Makefile
@@ -93,6 +93,7 @@ obj-$(CONFIG_MACH_OMAP_LDP)		+= board-ldp.o \
 					   mmc-twl4030.o \
 					   board-ldp-camera.o
 obj-$(CONFIG_MACH_OVERO)		+= board-overo.o \
+					   board-overo-camera.o \
 					   mmc-twl4030.o
 obj-$(CONFIG_MACH_OMAP3EVM)		+= board-omap3evm.o \
 					   mmc-twl4030.o \
diff --git git/arch/arm/mach-omap2/board-omap3beagle-camera.c git/arch/arm/mach-omap2/board-omap3beagle-camera.c
index 110c2c9..f6f65b2 100644
--- git/arch/arm/mach-omap2/board-omap3beagle-camera.c
+++ git/arch/arm/mach-omap2/board-omap3beagle-camera.c
@@ -372,6 +372,173 @@ struct mt9t112_platform_data mt9t112_pdata = {
 
 #endif				/* #ifdef CONFIG_VIDEO_MT9T112 */
 
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+#include <media/mt9p031.h>
+
+#define ISP_MT9P031_MCLK	216000000
+
+#define MT9P031_BIGGEST_FRAME_BYTE_SIZE	PAGE_ALIGN(2592 * 1944 * 2)
+
+static struct isp_interface_config mt9p031_if_config = {
+	.ccdc_par_ser 		= ISP_PARLL,
+	.dataline_shift 	= 0x1,
+	.hsvs_syncdetect 	= ISPCTRL_SYNC_DETECT_VSRISE,
+	.strobe 		= 0x0,
+	.prestrobe 		= 0x0,
+	.shutter		= 0x0,
+	.cam_mclk		= ISP_MT9P031_MCLK,
+	.wenlog			= ISPCCDC_CFG_WENLOG_AND,
+	.wait_hs_vs		= 1,
+	.u.par.par_bridge	= 0x0,
+	.u.par.par_clk_pol	= 0x0,
+};
+
+static struct v4l2_ifparm mt9p031_ifparm_s = {
+	.if_type = V4L2_IF_TYPE_YCbCr,
+	.u 	 = {
+		.ycbcr = {
+			.frame_start_on_rising_vs = 1,
+			.bt_sync_correct	= 0,
+			.swap			= 0,
+			.latch_clk_inv		= 0,
+			.nobt_hs_inv		= 0,	/* active high */
+			.nobt_vs_inv		= 0,	/* active high */
+			.clock_min		= MT9P031_CLK_MIN,
+			.clock_max		= MT9P031_CLK_MAX,
+		},
+	},
+};
+
+/**
+ * @brief mt9p031_ifparm - Returns the mt9p031 interface parameters
+ *
+ * @param p - pointer to v4l2_ifparm structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int mt9p031_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = mt9p031_ifparm_s;
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+static struct omap34xxcam_hw_config mt9p031_hwc = {
+	.dev_index		= 1,
+	.dev_minor		= -1,
+	.dev_type		= OMAP34XXCAM_SLAVE_SENSOR,
+	.u.sensor.sensor_isp	= 0,
+	.u.sensor.capture_mem	= MT9P031_BIGGEST_FRAME_BYTE_SIZE * 2,
+	.u.sensor.ival_default	= { 1, 15 },
+};
+#endif
+
+/**
+ * @brief mt9p031_set_prv_data - Returns mt9p031 omap34xx driver private data
+ *
+ * @param priv - pointer to omap34xxcam_hw_config structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int mt9p031_set_prv_data(void *priv)
+{
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	*hwc = mt9p031_hwc;
+	return 0;
+#else
+	return -EINVAL;
+#endif
+}
+
+/**
+ * @brief mt9p031_power_set - Power-on or power-off TVP5146 device
+ *
+ * @param power - enum, Power on/off, resume/standby
+ *
+ * @return result of operation - 0 is success
+ */
+static int mt9p031_power_set(struct v4l2_int_device *s,
+					enum v4l2_power power)
+{
+	struct omap34xxcam_videodev *vdev = s->u.slave->master->priv;
+
+	switch(power) {
+	case V4L2_POWER_OFF:
+	case V4L2_POWER_STANDBY:
+		isp_set_xclk(vdev->cam->isp, 0, CAM_USE_XCLKA);
+
+		if (regulator_is_enabled(cam_1v8_reg))
+			regulator_disable(cam_1v8_reg);
+		if (regulator_is_enabled(cam_2v8_reg))
+			regulator_disable(cam_2v8_reg);
+		break;
+
+	case V4L2_POWER_ON:
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+		isp_configure_interface(vdev->cam->isp, &mt9p031_if_config);
+#endif
+
+
+		/* turn on VDD */
+		regulator_enable(cam_1v8_reg);
+
+		mdelay(1);
+
+		/* turn on VDD_IO */
+		regulator_enable(cam_2v8_reg);
+
+		mdelay(50);
+
+		/* Set RESET_BAR to 0 */
+		gpio_set_value(LEOPARD_RESET_GPIO, 0);
+
+		/* Enable EXTCLK */
+		isp_set_xclk(vdev->cam->isp, 24000000, CAM_USE_XCLKA);
+
+		/*
+		 * Wait at least 70 CLK cycles (w/EXTCLK = 24MHz):
+		 * ((1000000 * 70) / 24000000) = aprox 2.91 us.
+		 */
+
+		udelay(3);
+
+		/* Set RESET_BAR to 1 */
+		gpio_set_value(LEOPARD_RESET_GPIO, 1);
+
+		/*
+		 * Wait at least 100 CLK cycles (w/EXTCLK = 24MHz):
+		 * ((1000000 * 100) / 24000000) = aprox 4.16 us.
+		 */
+
+		udelay(5);
+
+		break;
+
+	default:
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+struct mt9p031_platform_data mt9p031_pdata = {
+	.master		= "omap34xxcam",
+	.power_set	= mt9p031_power_set,
+	.priv_data_set	= mt9p031_set_prv_data,
+	.ifparm		= mt9p031_ifparm,
+};
+
+#endif	/* #ifdef CONFIG_VIDEO_MT9P031 */
+
+
 static int beagle_cam_probe(struct platform_device *pdev)
 {
 	cam_1v8_reg = regulator_get(&pdev->dev, "cam_1v8");
diff --git git/arch/arm/mach-omap2/board-omap3beagle.c git/arch/arm/mach-omap2/board-omap3beagle.c
index 2677b41..6c4dc1b 100644
--- git/arch/arm/mach-omap2/board-omap3beagle.c
+++ git/arch/arm/mach-omap2/board-omap3beagle.c
@@ -83,6 +83,13 @@ extern struct mt9v113_platform_data mt9v113_pdata;
 extern struct mt9t112_platform_data mt9t112_pdata;
 #endif
 
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+#include <media/v4l2-int-device.h>
+#include <media/mt9p031.h>
+#define MT9P031_I2C_ADDR		0x48
+extern struct mt9p031_platform_data mt9p031_pdata;
+#endif
+
 #define GPMC_CS0_BASE  0x60
 #define GPMC_CS_SIZE   0x30
 
@@ -614,6 +621,15 @@ static struct i2c_board_info __initdata beagle_lbcm3m1_i2c2_boardinfo[] = {
 #endif
 };
 
+static struct i2c_board_info __initdata beagle_li5m03_i2c2_boardinfo[] = {
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+	{
+		I2C_BOARD_INFO("mt9p031", MT9P031_I2C_ADDR),
+		.platform_data	= &mt9p031_pdata,
+	},
+#endif
+};
+
 static int __init omap3_beagle_i2c_init(void)
 {
 	omap_register_i2c_bus(1, 2600, beagle_i2c1_boardinfo,
@@ -636,6 +652,11 @@ static int __init omap3_beagle_i2c_init(void)
 					 " registering i2c2 bus for lbcm3m1\n");
 			omap_register_i2c_bus(2, 400,  beagle_lbcm3m1_i2c2_boardinfo,
 					ARRAY_SIZE(beagle_lbcm3m1_i2c2_boardinfo));
+		} else if (!strcmp(cameraboard_name, "li5m03")) {
+			printk(KERN_INFO "Beagle cameraboard:"
+					 " registering i2c2 bus for li5m03\n");
+			omap_register_i2c_bus(2, 400,  beagle_li5m03_i2c2_boardinfo,
+					ARRAY_SIZE(beagle_li5m03_i2c2_boardinfo));
 		} else {
 			omap_register_i2c_bus(2, 400, NULL, 0);
 		}
diff --git git/arch/arm/mach-omap2/board-overo-camera.c git/arch/arm/mach-omap2/board-overo-camera.c
new file mode 100644
index 0000000..b8acd04
--- /dev/null
+++ git/arch/arm/mach-omap2/board-overo-camera.c
@@ -0,0 +1,211 @@
+/*
+ * linux/arch/arm/mach-omap2/board-overo-camera.c
+ *
+ * Copyright (C) 2009 Analogue & Micro, Ltd.
+ *
+ * Based on linux/arch/arm/mach-omap2/board-procerus3530-camera.c
+ * Based on linux/arch/arm/mach-omap2/board-3430sdp-camera.c
+ *
+ * Initial code:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/mm.h>
+#include <linux/videodev2.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <plat/mux.h>
+#include <plat/board.h>
+#include <plat/control.h>
+
+#include <media/v4l2-int-device.h>
+
+/* Include V4L2 ISP-Camera driver related header file */
+#include <../drivers/media/video/omap34xxcam.h>
+#include <../drivers/media/video/isp/ispreg.h>
+
+
+#define CAM_USE_XCLKA		0
+
+#define CAM_RESET_GPIO		98
+
+
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+#include <media/mt9p031.h>
+
+#define ISP_MT9P031_MCLK	216000000
+
+#define MT9P031_BIGGEST_FRAME_BYTE_SIZE	PAGE_ALIGN(2592 * 1944 * 2)
+
+static struct isp_interface_config mt9p031_if_config = {
+	.ccdc_par_ser 		= ISP_PARLL,
+	.dataline_shift 	= 0x1,
+	.hsvs_syncdetect 	= ISPCTRL_SYNC_DETECT_VSRISE,
+	.strobe 		= 0x0,
+	.prestrobe 		= 0x0,
+	.shutter		= 0x0,
+	.cam_mclk		= ISP_MT9P031_MCLK,
+	.wenlog			= ISPCCDC_CFG_WENLOG_AND,
+	.wait_hs_vs		= 1,
+	.u.par.par_bridge	= 0x0,
+	.u.par.par_clk_pol	= 0x0,
+};
+
+static struct v4l2_ifparm mt9p031_ifparm_s = {
+	.if_type = V4L2_IF_TYPE_YCbCr,
+	.u 	 = {
+		.ycbcr = {
+			.frame_start_on_rising_vs = 1,
+			.bt_sync_correct	= 0,
+			.swap			= 0,
+			.latch_clk_inv		= 0,
+			.nobt_hs_inv		= 0,	/* active high */
+			.nobt_vs_inv		= 0,	/* active high */
+			.clock_min		= MT9P031_CLK_MIN,
+			.clock_max		= MT9P031_CLK_MAX,
+		},
+	},
+};
+
+static int mt9p031_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = mt9p031_ifparm_s;
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+static struct omap34xxcam_hw_config mt9p031_hwc = {
+	.dev_index		= 1,
+	.dev_minor		= -1,
+	.dev_type		= OMAP34XXCAM_SLAVE_SENSOR,
+	.u.sensor.sensor_isp	= 0,
+	.u.sensor.capture_mem	= MT9P031_BIGGEST_FRAME_BYTE_SIZE * 2,
+	.u.sensor.ival_default	= { 1, 14 },
+};
+#endif
+
+static int mt9p031_set_prv_data(void *priv)
+{
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	*hwc = mt9p031_hwc;
+	return 0;
+#else
+	return -EINVAL;
+#endif
+}
+
+
+static int mt9p031_power_set(struct v4l2_int_device *s, enum v4l2_power power)
+{
+	struct omap34xxcam_videodev *vdev = s->u.slave->master->priv;
+
+	switch(power) {
+	case V4L2_POWER_OFF:
+	case V4L2_POWER_STANDBY:
+		isp_set_xclk(vdev->cam->isp, 0, CAM_USE_XCLKA);
+		break;
+
+	case V4L2_POWER_ON:
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+		isp_configure_interface(vdev->cam->isp, &mt9p031_if_config);
+#endif
+
+		gpio_set_value(CAM_RESET_GPIO, 0);
+		isp_set_xclk(vdev->cam->isp, 24000000, CAM_USE_XCLKA);
+		udelay(3);
+		gpio_set_value(CAM_RESET_GPIO, 1);
+		udelay(5);
+		break;
+	}
+
+	return 0;
+}
+
+struct mt9p031_platform_data overo_mt9p031_platform_data = {
+	.master		= "omap34xxcam",
+	.power_set	= mt9p031_power_set,
+	.priv_data_set	= mt9p031_set_prv_data,
+	.ifparm		= mt9p031_ifparm,
+};
+
+static int overo_cam_probe(struct platform_device *pdev)
+{
+	if (gpio_request(CAM_RESET_GPIO, "cam_rst") != 0) {
+		dev_err(&pdev->dev, "Could not request GPIO %d",
+			CAM_RESET_GPIO);
+		return -ENODEV;
+	}
+
+	gpio_direction_output(CAM_RESET_GPIO, 0);
+
+	dev_info(&pdev->dev, "overo_mt9p031: driver registration complete\n");
+
+	return 0;
+}
+
+static int overo_cam_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "overo_cam_remove\n");
+
+	gpio_free(CAM_RESET_GPIO);
+
+	return 0;
+}
+
+static int overo_cam_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int overo_cam_resume(struct device *dev)
+{
+	return 0;
+}
+
+static struct dev_pm_ops overo_cam_pm_ops = {
+	.suspend = overo_cam_suspend,
+	.resume  = overo_cam_resume,
+};
+
+static struct platform_driver overo_cam_driver = {
+	.probe		= overo_cam_probe,
+	.remove		= overo_cam_remove,
+	.driver		= {
+		.name	= "overo_cam",
+		.pm	= &overo_cam_pm_ops,
+	},
+};
+
+/**
+ * @brief overo_mt9p031_init - module init function. Should be called before
+ *                          any client driver init call
+ *
+ * @return result of operation - 0 is success
+ */
+int __init overo_mt9p031_init(void)
+{
+	platform_driver_register(&overo_cam_driver);
+
+	return 0;
+}
+late_initcall(overo_mt9p031_init);
+
+
+#endif
+
diff --git git/arch/arm/mach-omap2/board-overo.c git/arch/arm/mach-omap2/board-overo.c
index 2595f81..da5568c 100644
--- git/arch/arm/mach-omap2/board-overo.c
+++ git/arch/arm/mach-omap2/board-overo.c
@@ -59,6 +59,7 @@
 #include "pm.h"
 #include "omap3-opp.h"
 
+
 #define OVERO_GPIO_BT_XGATE	15
 #define OVERO_GPIO_W2W_NRESET	16
 #define OVERO_GPIO_PENDOWN	114
@@ -603,12 +604,45 @@ static struct i2c_board_info __initdata overo_i2c_boardinfo[] = {
 	},
 };
 
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+#define MT9P031_I2C_ADDR		0x5D
+#include <media/mt9p031.h>
+
+extern struct mt9p031_platform_data overo_mt9p031_platform_data;
+
+static struct i2c_board_info __initdata overo_i2c_mt9p031_info[] = {
+	{
+		I2C_BOARD_INFO("mt9p031", MT9P031_I2C_ADDR),
+		.platform_data = &overo_mt9p031_platform_data,
+	},
+};
+
+static struct platform_device overo_cam_device = {
+	.name		= "overo_cam",
+	.id		= -1,
+};
+
+int overo_cam_init(void)
+{
+	return platform_device_register(&overo_cam_device);
+}
+
+#else
+static inline int overo_cam_init(void) { return 0; }
+#endif
+
+
 static int __init overo_i2c_init(void)
 {
 	omap_register_i2c_bus(1, 2600, overo_i2c_boardinfo,
 			ARRAY_SIZE(overo_i2c_boardinfo));
-	/* i2c2 pins are used for gpio */
+
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+	omap_register_i2c_bus(3, 100, overo_i2c_mt9p031_info,
+			ARRAY_SIZE(overo_i2c_mt9p031_info));
+#else
 	omap_register_i2c_bus(3, 400, NULL, 0);
+#endif
 	return 0;
 }
 
@@ -689,6 +723,7 @@ static void __init overo_init(void)
 	overo_spi_init();
 	overo_init_smsc911x();
 	overo_display_init();
+	overo_cam_init();
 
 	/* Ensure SDRC pins are mux'd for self-refresh */
 	omap_mux_init_signal("sdrc_cke0", OMAP_PIN_OUTPUT);
diff --git git/drivers/media/video/Kconfig git/drivers/media/video/Kconfig
index 4c1fb0f..0f9b660 100644
--- git/drivers/media/video/Kconfig
+++ git/drivers/media/video/Kconfig
@@ -354,6 +354,14 @@ config VIDEO_MT9P012
 	  MT9P012 camera.  It is currently working with the TI OMAP3
 	  camera controller.
 
+config VIDEO_MT9P031
+	tristate "Aptina MT9P031 raw sensor driver (5MP)"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Aptina 
+	  MT9P031 camera.  It is currently working with the TI OMAP3
+	  camera controller.
+
 config VIDEO_MT9T112
 	tristate "mt9t112 support"
 	depends on I2C && VIDEO_V4L2
diff --git git/drivers/media/video/Makefile git/drivers/media/video/Makefile
index fb7e46c..974b1d9 100644
--- git/drivers/media/video/Makefile
+++ git/drivers/media/video/Makefile
@@ -128,6 +128,7 @@ obj-$(CONFIG_VIDEO_CAFE_CCIC) += cafe_ccic.o
 obj-y				+= isp/
 obj-$(CONFIG_VIDEO_OMAP3)	+= omap34xxcam.o
 obj-$(CONFIG_VIDEO_MT9P012)     += mt9p012.o
+obj-$(CONFIG_VIDEO_MT9P031)    	+= mt9p031.o
 obj-$(CONFIG_VIDEO_MT9T112)	+= mt9t112.o
 obj-$(CONFIG_VIDEO_DW9710)	+= dw9710.o
 obj-$(CONFIG_VIDEO_TPS61059)    += tps61059.o
diff --git git/drivers/media/video/mt9p031.c git/drivers/media/video/mt9p031.c
new file mode 100644
index 0000000..2c56d90
--- /dev/null
+++ git/drivers/media/video/mt9p031.c
@@ -0,0 +1,2108 @@
+/*
+ * mt9p031.c - mt9p031 sensor driver
+ *
+ * Originally based on code from Procerus Technologies
+ * http://gitorious.org/procerus-vpu-main-linux-kernel
+ *
+ * Copyright (C) 2010 Procerus Technologies.
+ *
+ * Contributors:
+ * 	Evan Andersen <evana@procerus.com>
+ * 	Neil Johnson <neilj@procerus.com>
+ *
+ * Modifications:
+ *	Scott Ellis <scott@jumpnowtek.com>
+ *
+ * Heavily modified for a custom board with a max pixel_clock of 48 MHz due
+ * to power supplies. Only 2560x1920 images are supported. The pixel_clock 
+ * speed and image size restrict max frame rate to 7 fps. You can resize the 
+ * images down to 1280x960 or 640x480 using the OMAP ISP resizer via the
+ * V4L2 interface.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <media/v4l2-int-device.h>
+
+#include <media/mt9p031.h>
+#include "mt9p031_regs.h"
+
+#define DRIVER_NAME  "mt9p031"
+
+/* The ID values we are looking for */
+#define MT9P031_CHIP_VERSION		0x1801
+
+#define MT9P031_I2C_RETRY_COUNT	5
+
+/* incoming clock from the isp */
+#define MT9P031_DEFAULT_XCLK	24000000
+
+/* outgoing clock from the sensor */
+#define MT9P031_DEFAULT_PIXCLK	48000000
+
+
+#define MT9P031_ACTIVE_COL_START	16
+#define MT9P031_ACTIVE_COL_END		2607
+#define MT9P031_ACTIVE_ROW_START	54
+#define MT9P031_ACTIVE_ROW_END		1997
+
+/* default setup for 2560x1920 pixel images */
+#define MT9P031_DEFAULT_COL_START	32
+#define MT9P031_DEFAULT_ROW_START	66
+#define MT9P031_DEFAULT_COL_SIZE	2560
+#define MT9P031_DEFAULT_ROW_SIZE	1920
+
+/* max width and height of the sensors active region */
+#define MT9P031_IMAGE_WIDTH_MAX		2592
+#define MT9P031_IMAGE_HEIGHT_MAX	1944
+
+
+/* Exposure time values */
+#define MT9P031_DEF_MIN_EXPOSURE	63
+#define MT9P031_DEF_MAX_EXPOSURE	142644
+#define MT9P031_DEF_EXPOSURE	    	10000
+#define MT9P031_EXPOSURE_STEP       	1
+
+static unsigned long pixel_clock = MT9P031_DEFAULT_PIXCLK;
+module_param(pixel_clock, ulong, 0644);
+MODULE_PARM_DESC(pixel_clock, "Pixel clock speed, Hz)");
+
+static int test_pattern = -1;
+module_param(test_pattern, int, 0644);
+MODULE_PARM_DESC(test_pattern, "Sensor test pattern 0-8, default off = -1");
+
+static int debug;
+module_param(debug, bool, 0644);
+MODULE_PARM_DESC(debug, "Debug enabled 0 or 1)");
+
+enum mt9p031_token {
+	MT9P031_TOK_WRITE,
+	MT9P031_TOK_OR,
+	MT9P031_TOK_AND,
+	MT9P031_TOK_TERM,
+	MT9P031_TOK_DELAY,
+	MT9P031_TOK_SKIP,
+};
+
+/**
+ * struct mt9p031_reg - mt9p031 register format
+ * @reg: 16-bit offset to register
+ * @val: 16-bit register value
+ *
+ * Define a structure for MT9P031 register initialization values
+ */
+struct mt9p031_reg {
+	enum mt9p031_token token;
+	u16 reg;
+	u16 val;
+};
+
+/**
+ * struct mt9p031_pll_settings - struct for storage of sensor pll values
+ * @vt_pix_clk_div: vertical pixel clock divider
+ * @vt_sys_clk_div: veritcal system clock divider
+ * @pre_pll_div: pre pll divider
+ * @fine_int_tm: fine resolution interval time
+ * @frame_lines: number of lines in frame
+ * @line_len: number of pixels in line
+ * @min_pll: minimum pll multiplier
+ * @max_pll: maximum pll multiplier
+ */
+struct mt9p031_pll_settings {
+	u8 pll_m_factor;
+	u8 pll_n_divider;
+	u8 pll_p1_divider;
+	u8 use_pll;
+	u8 use_extclk;
+};
+ 
+/**
+ * struct capture_size - image capture size information
+ * @width: image width in pixels
+ * @height: image height in pixels
+ * @max_fps: max frame rate at a given pixclk
+ */
+struct mt9p031_capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+/*
+ * Array of image sizes supported by MT9P031.  These must be ordered from
+ * smallest image size to largest.
+ */
+const static struct mt9p031_capture_size mt9p031_sizes[] = {
+	[MT9P031_2560X1920] = { 2560, 1920 },
+};
+
+
+/**
+ * struct mt9p031_sensor - main structure for storage of sensor information
+ */
+struct mt9p031_sensor {
+	struct device *dev;
+	struct mt9p031_platform_data *pdata;
+	struct v4l2_int_device *v4l2_int_device;
+	struct v4l2_pix_format pix;
+	struct mt9p031_pll_settings pll;
+	int ver;
+	int detected;
+	int streaming;
+	unsigned long xclk_current;
+	unsigned long pixclk;
+	unsigned int row_clk;
+	u16 row_start;
+	u16 col_start;
+	u16 row_size;
+	u16 col_size;
+	u16 h_blank;
+	u16 v_blank;
+	unsigned long shutter_width;
+	unsigned long shutter_delay;
+	unsigned long exposure;
+	unsigned int green1_gain;
+	unsigned int blue_gain;
+	unsigned int red_gain;
+	unsigned int green2_gain;
+	u8 row_bin;	
+	u8 row_skip;
+	u8 col_bin;
+	u8 col_skip;	
+	int fps;
+	int max_fps;
+	u8 output_size;
+};
+
+/* list of image formats supported by mt9p031 sensor */
+const static struct v4l2_fmtdesc mt9p031_format = {
+	.type		= V4L2_BUF_TYPE_VIDEO_CAPTURE,
+	.index		= 1,
+	.description    = "Bayer10 (GrR/BGb)",
+	.pixelformat    = V4L2_PIX_FMT_SGRBG10,
+};
+
+
+/* Enters soft standby, all settings are maintained */
+const static struct mt9p031_reg stream_off_list[] = {
+	{ MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_CHIP_ENABLE },
+	{ MT9P031_TOK_TERM, .reg = 0, .val = 0 }
+};
+
+/* Exits soft standby */
+const static struct mt9p031_reg stream_on_list[] = {
+	{ MT9P031_TOK_OR, REG_FRAME_RESTART, RESTART_FRAME | PAUSE_RESTART },
+	{ MT9P031_TOK_DELAY, 0x00, 1 },
+	{ MT9P031_TOK_AND, REG_FRAME_RESTART, ~PAUSE_RESTART },
+	{ MT9P031_TOK_TERM, 0, 0 }
+};
+
+
+#define INVERT_PIXEL_CLOCK (1 << 15)
+const static struct mt9p031_reg mt9p031_common[] = {
+	{ MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_CHIP_ENABLE },
+	{ MT9P031_TOK_WRITE, REG_RESET, 0x01 },
+	{ MT9P031_TOK_DELAY, 0x00, 5 },
+	{ MT9P031_TOK_WRITE, REG_RESET, 0 },
+	{ MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES},
+	{ MT9P031_TOK_WRITE, REG_PIXEL_CLOCK_CONTROL, INVERT_PIXEL_CLOCK},
+	{ MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES },
+	{ MT9P031_TOK_TERM, 0, 0 }
+};
+
+static struct v4l2_queryctrl mt9p031_ctrl[] = {
+	{
+		.id = V4L2_CID_EXPOSURE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Exposure",
+		.minimum = MT9P031_DEF_MIN_EXPOSURE,
+		.maximum = MT9P031_DEF_MAX_EXPOSURE,
+		.step = MT9P031_EXPOSURE_STEP,
+		.default_value = MT9P031_DEF_EXPOSURE,
+	},
+	{
+		.id = V4L2_CID_GAIN,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Global Gain",
+		.minimum = 1,
+		.maximum = 161,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_MT9P031_GREEN1_GAIN,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Green1 Gain",
+		.minimum = 1,
+		.maximum = 161,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_MT9P031_BLUE_GAIN,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Blue Gain",
+		.minimum = 1,
+		.maximum = 161,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_MT9P031_RED_GAIN,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Red Gain",
+		.minimum = 1,
+		.maximum = 161,
+		.step = 1,
+		.default_value = 1,
+	},
+	{
+		.id = V4L2_MT9P031_GREEN2_GAIN,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Green1 Gain",
+		.minimum = 1,
+		.maximum = 161,
+		.step = 1,
+		.default_value = 1,
+	},
+};
+
+/**
+ * mt9p031_read_reg - Read a value from a register in an mt9p031 sensor device
+ * @client: i2c driver client structure
+ * @data_length: length of data to be read
+ * @reg: register address / offset
+ * @val: stores the value that gets read
+ */
+static int mt9p031_read_reg(struct i2c_client *client, u16 reg, u16 *val)
+{
+	s32 res = i2c_smbus_read_word_data(client, reg);
+	if (res >= 0) {
+		*val = swab16(res);
+		return 0;
+	}
+
+	v4l_dbg(1, debug, client, "read from offset 0x%x error %d", reg, res);
+
+	return res;
+}
+/**
+ * mt9p031_write_reg - Write a value to a register in an mt9p031 sensor device
+ * @client: i2c driver client structure
+ * @data_length: length of data to be read
+ * @reg: register address / offset
+ * @val: value to be written to specified register
+ */
+static int mt9p031_write_reg(struct i2c_client *client, u16 reg, u16 val)
+{
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[4];
+	int retry = 0;
+	u16 data_length = 2;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+again:
+	msg->addr = client->addr;
+	msg->flags = 0;
+	msg->len = 2 + data_length;
+	msg->buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8) (reg >> 8);;
+	data[1] = (u8) (reg & 0xff);
+
+	data[2] = (u8) (val >> 8);
+	data[3] = (u8) (val & 0xff);
+	err = i2c_smbus_write_word_data(client, reg, swab16(val));
+	if (err >= 0)
+		return 0;
+
+	v4l_dbg(1, debug, client, "wrote 0x%x to offset 0x%x error %d", 
+		val, reg, err);
+
+	if (retry <= MT9P031_I2C_RETRY_COUNT) {
+		v4l_warn(client, "retry ... %d", retry);
+		retry++;
+		mdelay(20);
+		goto again;
+	}
+
+	return err;
+}
+
+static int mt9p031_reg_and(struct i2c_client *client, u16 reg, u16 val)
+{
+	u16 reg_val = 0;
+	int err;
+
+	err = mt9p031_read_reg( client, reg, &reg_val );
+	if (err)
+		return err;
+
+	err = mt9p031_write_reg( client, reg, (reg_val & val) );
+
+	return err;
+}
+
+static int mt9p031_reg_or(struct i2c_client *client, u16 reg, u16 val)
+{
+	u16 reg_val = 0;
+	int err;
+
+	err = mt9p031_read_reg( client, reg, &reg_val );
+	if (err)
+		return err;
+
+	err = mt9p031_write_reg( client, reg, (reg_val | val) );
+
+	return err;
+}
+
+/**
+ * mt9p031_write_regs - Initializes a list of MT9P031 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ */
+static int mt9p031_write_regs(struct i2c_client *client,
+			      const struct mt9p031_reg reglist[])
+{
+	int err;
+	const struct mt9p031_reg *next = reglist;
+
+	for (; next->token != MT9P031_TOK_TERM; next++) {
+		switch(next->token) {
+		case MT9P031_TOK_WRITE:
+			err = mt9p031_write_reg(client, next->reg, next->val);
+			break;
+		case MT9P031_TOK_OR:
+			err = mt9p031_reg_or(client, next->reg, next->val);
+			break;
+		case MT9P031_TOK_AND:
+			err = mt9p031_reg_and(client, next->reg, next->val);
+			break;
+		case MT9P031_TOK_DELAY:
+			mdelay(next->val);
+			err = 0;
+			break;
+		default:
+			err = 0;
+			break;
+		}
+
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+#define _REG(n) { .name=#n, .offset=n }
+static struct {
+    char *name;
+    int offset;
+} _reg_list[] = {
+  _REG(REG_CHIP_VERSION),
+  _REG(REG_ROW_START),
+  _REG(REG_COLUMN_START),
+  _REG(REG_ROW_HEIGHT),
+  _REG(REG_COLUMN_WIDTH),
+  _REG(REG_HORIZONTAL_BLANK),
+  _REG(REG_VERTICAL_BLANK),
+  _REG(REG_OUTPUT_CONTROL),
+  _REG(REG_SHUTTER_WIDTH_UPPER),
+  _REG(REG_SHUTTER_WIDTH_LOWER),
+  _REG(REG_PIXEL_CLOCK_CONTROL),
+  _REG(REG_FRAME_RESTART),
+  _REG(REG_SHUTTER_DELAY),
+  _REG(REG_RESET),
+  _REG(REG_READ_MODE1),
+  _REG(REG_READ_MODE2),
+  _REG(REG_ROW_ADDRESS_MODE),
+  _REG(REG_COL_ADDRESS_MODE),
+  _REG(REG_PLL_CONTROL),
+  _REG(REG_PLL_CONFIG1),
+  _REG(REG_PLL_CONFIG2),
+
+  _REG(REG_CHIP_ENABLE_SYNC),
+
+  _REG(REG_RESERVED_27_REG),
+  _REG(REG_GREEN1_GAIN),
+  _REG(REG_BLUE_GAIN),
+  _REG(REG_RED_GAIN),
+  _REG(REG_GREEN2_GAIN),
+  _REG(REG_BLACK_LEVEL),
+  _REG(REG_ROW_BLK_DEF_OFFSET),
+  _REG(REG_RESERVED_4E_REG),
+  _REG(REG_RESERVED_50_REG),
+  _REG(REG_RESERVED_51_REG),
+  _REG(REG_RESERVED_52_REG),
+  _REG(REG_RESERVED_53_REG),
+  _REG(REG_CAL_COARSE),
+  _REG(REG_CAL_TARGET),
+  _REG(REG_GREEN1_OFFSET),
+  _REG(REG_GREEN2_OFFSET),
+  _REG(REG_BLK_LVL_CALIB),
+  _REG(REG_RED_OFFSET),
+  _REG(REG_BLUE_OFFSET),
+
+  _REG(REG_TEST_PATTERN_CONTROL),
+  _REG(REG_TEST_PATTERN_GREEN),
+  _REG(REG_TEST_PATTERN_RED),
+  _REG(REG_TEST_PATTERN_BLUE),
+  _REG(REG_TEST_PATTERN_BAR_WIDTH),
+};
+
+
+static void mt9p031_dump_regs(struct i2c_client *client)
+{
+    u16 val, i;
+    int err;
+
+    for (i = 0; i < ARRAY_SIZE(_reg_list); i++) {
+        err = mt9p031_read_reg(client, _reg_list[i].offset, &val);
+
+	if (err == 0) {
+            dev_info(&client->dev, "%32s[0x%04X] = 0x%04X\n", 
+			_reg_list[i].name, _reg_list[i].offset, val);
+	}
+	else {
+            dev_info(&client->dev, "%32s[0x%04X] read error: %d\n", 
+			_reg_list[i].name, _reg_list[i].offset, err);
+	}
+    }
+}
+
+struct mt9p031_reg set_pll_reg[] = {
+	{MT9P031_TOK_OR, REG_PLL_CONTROL, PLL_CTRL_POWER_PLL},
+	{MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_WRITE, REG_PLL_CONFIG1, 0x6404},
+	{MT9P031_TOK_WRITE, REG_PLL_CONFIG2, 0x0000},
+	{MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_DELAY, 0, 1},
+	{MT9P031_TOK_OR, REG_PLL_CONTROL, PLL_CTRL_USE_PLL},
+	{MT9P031_TOK_TERM, 0, 0}
+}; 
+static int mt9p031_set_pll(struct mt9p031_pll_settings *pll_settings, 
+			   struct mt9p031_sensor *sensor)
+{
+	int err = 0;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	unsigned long tmp_clk;
+
+	if (sensor->xclk_current > 27000000)
+		return -EINVAL;
+
+	if (pll_settings->pll_n_divider > 63
+	   || pll_settings->pll_m_factor < 16
+	   || pll_settings->pll_p1_divider > 127
+	   || pll_settings->pll_p1_divider % 2 != 0) {
+		dev_err(&client->dev, "mt9p031_set_pll() fail 1\n");
+		return -EINVAL;
+	}
+
+	tmp_clk = sensor->xclk_current / pll_settings->pll_n_divider;
+	if (tmp_clk < 2000000 || tmp_clk > 13500000) {
+		dev_err(&client->dev, "mt9p031_set_pll() fail 2\n");
+		return -EINVAL;
+	}
+
+	tmp_clk *= pll_settings->pll_m_factor;
+	if (tmp_clk < 180000000 || tmp_clk > 360000000) {
+		dev_err(&client->dev, "mt9p031_set_pll() fail 3\n");
+		return -EINVAL;
+	}
+
+	tmp_clk /= pll_settings->pll_p1_divider;
+	if (tmp_clk > 96000000) {
+		dev_err(&client->dev, "mt9p031_set_pll() fail 4\n");
+		return -EINVAL;
+	}
+
+	set_pll_reg[2].val = (pll_settings->pll_m_factor<<PLL_M_FACTOR_SHIFT) |
+				((pll_settings->pll_n_divider-1)<<PLL_N_DIVIDER_SHIFT);
+
+	set_pll_reg[3].val = (pll_settings->pll_p1_divider-1);
+
+	err = mt9p031_write_regs(client, set_pll_reg);
+	if (err) {
+		dev_err(&client->dev, "mt9p031_set_pll() fail 5\n");
+		return err;
+	}
+
+	dev_info(&client->dev, "sensor->pixclk = %lu\n", tmp_clk);
+
+	sensor->pixclk = tmp_clk; 
+
+	return 0;
+}
+
+static int mt9p031_disable_pll(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+
+	err = mt9p031_reg_and(client, REG_PLL_CONTROL, 
+			~(PLL_CTRL_USE_PLL | PLL_CTRL_POWER_PLL));
+
+	if (err)
+		return err;
+
+	sensor->pixclk = sensor->xclk_current;
+
+	return 0;
+}
+
+struct mt9p031_reg set_test_reg[] = {
+	{ MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES},
+	{ MT9P031_TOK_WRITE, REG_TEST_PATTERN_GREEN, 0 },
+	{ MT9P031_TOK_WRITE, REG_TEST_PATTERN_BLUE, 0 },
+	{ MT9P031_TOK_WRITE, REG_TEST_PATTERN_RED, 0 },
+	{ MT9P031_TOK_WRITE, REG_TEST_PATTERN_BAR_WIDTH, 128 },
+	{ MT9P031_TOK_WRITE, REG_TEST_PATTERN_CONTROL, 8 },
+	{ MT9P031_TOK_WRITE, REG_READ_MODE2, 0 },
+	{ MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES},
+	{ MT9P031_TOK_TERM, 0, 0}		
+};
+static int mt9p031_disable_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_disable_test()\n"); 
+
+	set_test_reg[1].val = 0;
+	set_test_reg[2].val = 0;
+	set_test_reg[3].val = 0;
+	set_test_reg[4].val = 0;
+	set_test_reg[5].val = 0;
+	set_test_reg[6].val = 0x0040;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_color_field_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_color_field_test()\n"); 
+
+	set_test_reg[1].val = 2048;
+	set_test_reg[2].val = 1024;
+	set_test_reg[3].val = 512;
+	set_test_reg[4].val = 64;
+	set_test_reg[5].val = 0x01 | (0 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_horizontal_gradient_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_horizontal_gradient_test()\n"); 
+
+	set_test_reg[1].val = 0;
+	set_test_reg[2].val = 0;
+	set_test_reg[3].val = 0;
+	set_test_reg[4].val = 0;
+	set_test_reg[5].val = 0x01 | (1 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_vertical_gradient_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_vertical_gradient_test()\n"); 
+
+	set_test_reg[1].val = 0;
+	set_test_reg[2].val = 0;
+	set_test_reg[3].val = 0;
+	set_test_reg[4].val = 0;
+	set_test_reg[5].val = 0x01 | (2 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_diagonal_gradient_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_diagonal_gradient_test()\n"); 
+
+	set_test_reg[1].val = 0;
+	set_test_reg[2].val = 0;
+	set_test_reg[3].val = 0;
+	set_test_reg[4].val = 0;
+	set_test_reg[5].val = 0x01 | (3 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_classic_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_classic_test()\n"); 
+
+	set_test_reg[1].val = 512;
+	set_test_reg[2].val = 256;
+	set_test_reg[3].val = 384;
+	set_test_reg[4].val = 64;
+	set_test_reg[5].val = 0x01 | (4 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_walking_ones_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_walking_ones_test()\n"); 
+
+	set_test_reg[1].val = 0;
+	set_test_reg[2].val = 0;
+	set_test_reg[3].val = 0;
+	set_test_reg[4].val = 0;
+	set_test_reg[5].val = 0x01 | (5 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_mono_horizontal_bars_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_mono_horizontal_bars_test()\n"); 
+
+	set_test_reg[1].val = 3072;
+	set_test_reg[2].val = 8;
+	set_test_reg[3].val = 0;
+	set_test_reg[4].val = 32;
+	set_test_reg[5].val = 0x01 | (6 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_mono_vertical_bars_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_mono_vertical_bars_test()\n"); 
+
+	set_test_reg[1].val = 1024;
+	set_test_reg[2].val = 256;
+	set_test_reg[3].val = 0;
+	set_test_reg[4].val = 128;
+	set_test_reg[5].val = 0x01 | (7 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_vert_color_bar_test(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	dev_info(&client->dev, "mt9p031_set_vert_color_bar_test()\n"); 
+
+	set_test_reg[1].val = 256;
+	set_test_reg[2].val = 1024;
+	set_test_reg[3].val = 2048;
+	set_test_reg[4].val = 64;
+	set_test_reg[5].val = 0x01 | (8 << 3);
+	set_test_reg[6].val = 0;
+	
+	return mt9p031_write_regs(client, set_test_reg);
+}
+
+static int mt9p031_set_test_pattern(struct mt9p031_sensor *sensor, int test)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+
+	switch (test) {
+	case 0:
+		err = mt9p031_set_color_field_test(sensor);
+		break;
+	case 1:
+		err = mt9p031_set_horizontal_gradient_test(sensor);
+		break;
+
+	case 2:
+		err = mt9p031_set_vertical_gradient_test(sensor);
+		break;
+
+	case 3:
+		err = mt9p031_set_diagonal_gradient_test(sensor);
+		break;
+
+	case 4:
+		err = mt9p031_set_classic_test(sensor);
+		break;
+
+	case 5:
+		err = mt9p031_set_walking_ones_test(sensor);
+		break;
+
+	case 6:
+		err = mt9p031_set_mono_horizontal_bars_test(sensor);
+		break;
+	
+	case 7:
+		err = mt9p031_set_mono_vertical_bars_test(sensor);
+		break;
+
+	case 8:
+		err = mt9p031_set_vert_color_bar_test(sensor);
+		break;
+
+	default:
+		dev_info(&client->dev, "mt9p031_set_test_pattern(%d) ignored\n", 
+			test);
+		err = mt9p031_disable_test(sensor);
+		break;
+	}	
+		
+	return err;	
+}
+
+static struct mt9p031_reg set_gains[] = {
+	{ MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES },
+	{ MT9P031_TOK_WRITE, REG_GREEN1_GAIN, 8 },
+	{ MT9P031_TOK_WRITE, REG_BLUE_GAIN, 8 },
+	{ MT9P031_TOK_WRITE, REG_RED_GAIN, 8 },
+	{ MT9P031_TOK_WRITE, REG_GREEN2_GAIN, 8 },
+	{ MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES },
+	{ MT9P031_TOK_TERM, 0, 0 }
+};
+/*
+  For gain values in the range [1:25], we use analog gain in 0.125 increments
+	for gains up to 4.0X -> ((25 + 7) / 8) = 4.0
+  For gain values in the range [26:41], we use analog gain and multiplier for
+     increments of 0.25 up to 8.0X -> ((41 - 9) / 8) * 2 = 8.0
+  For gain values [42:161] analog gain and analog multiplier = 8.0 = AGC
+  	digital gain = DGC = 1 + ([1:120] / 8) = 1.125 to 16.0
+
+	Digital Gain Min = AGC * 1.125 = 9
+	Digital Gain Max = AGC * 16.0 = 128
+*/
+static unsigned int mt9p031_calculate_gain_reg(int val)
+{
+	unsigned int reg_val;
+
+	if (val < 1)
+		val = 1;
+	else if (val > 161)
+		val = 161;
+
+	if (val <= 25)
+		// just the analog gain field [1:32]
+		reg_val = val + 7;
+	else if (val <= 41)
+		// analog gain field[17:31] and analog multiplier[1]
+		reg_val = (val - 9) | ANALOG_MULTIPLIER_MASK;
+	else
+		// analog gain[31], analog multiplier[1] and digital gain[1-120]
+		reg_val = 32 | ANALOG_MULTIPLIER_MASK
+				| ((val - 41) << DIGITAL_GAIN_SHIFT);
+
+	return reg_val;
+}
+
+static int mt9p031_set_global_gain(struct mt9p031_sensor *sensor, int val)
+{
+	int ret;
+	unsigned int reg_val;
+	struct i2c_client *client = to_i2c_client(sensor->dev);			
+
+	reg_val = mt9p031_calculate_gain_reg(val);
+
+	set_gains[1].val = reg_val;
+	set_gains[2].val = reg_val;
+	set_gains[3].val = reg_val;
+	set_gains[4].val = reg_val;
+
+	ret = mt9p031_write_regs(client, set_gains);
+
+	if (!ret) {
+		sensor->green1_gain = val;
+		sensor->blue_gain = val;
+		sensor->red_gain = val;
+		sensor->green2_gain = val;
+	}
+	
+	return ret;
+}
+
+static int mt9p031_set_all_gains(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);			
+
+	set_gains[1].val = mt9p031_calculate_gain_reg(sensor->green1_gain);
+	set_gains[2].val = mt9p031_calculate_gain_reg(sensor->blue_gain);
+	set_gains[3].val = mt9p031_calculate_gain_reg(sensor->red_gain);
+	set_gains[4].val = mt9p031_calculate_gain_reg(sensor->green2_gain);
+
+	return mt9p031_write_regs(client, set_gains);
+}
+
+static int mt9p031_set_green1_gain(struct mt9p031_sensor *sensor, int val)
+{
+	int ret;
+	unsigned int reg_val;
+	struct i2c_client *client = to_i2c_client(sensor->dev);			
+
+	reg_val = mt9p031_calculate_gain_reg(val);
+
+	ret = mt9p031_write_reg(client, REG_GREEN1_GAIN, reg_val);
+
+	if (!ret)
+		sensor->green1_gain = val;
+	else
+		dev_warn(&client->dev, "green1 gain failed!\n");
+
+	return ret;
+}
+
+static int mt9p031_set_blue_gain(struct mt9p031_sensor *sensor, int val)
+{
+	int ret;
+	unsigned int reg_val;
+	struct i2c_client *client = to_i2c_client(sensor->dev);			
+
+	reg_val = mt9p031_calculate_gain_reg(val);
+
+	ret = mt9p031_write_reg(client, REG_BLUE_GAIN, reg_val);
+
+	if (!ret)
+		sensor->blue_gain = val;
+	else
+		dev_warn(&client->dev, "blue gain failed!\n");
+
+	return ret;
+}
+
+static int mt9p031_set_red_gain(struct mt9p031_sensor *sensor, int val)
+{
+	int ret;
+	unsigned int reg_val;
+	struct i2c_client *client = to_i2c_client(sensor->dev);			
+
+	reg_val = mt9p031_calculate_gain_reg(val);
+
+	ret = mt9p031_write_reg(client, REG_RED_GAIN, reg_val);
+
+	if (!ret)
+		sensor->red_gain = val;
+	else
+		dev_warn(&client->dev, "red gain failed!\n");
+
+	return ret;
+}
+
+static int mt9p031_set_green2_gain(struct mt9p031_sensor *sensor, int val)
+{
+	int ret;
+	unsigned int reg_val;
+	struct i2c_client *client = to_i2c_client(sensor->dev);			
+
+	reg_val = mt9p031_calculate_gain_reg(val);
+
+	ret = mt9p031_write_reg(client, REG_GREEN2_GAIN, reg_val);
+
+	if (!ret)
+		sensor->green1_gain = val;
+	else
+		dev_warn(&client->dev, "green2 gain failed!\n");
+
+	return ret;
+}
+
+struct mt9p031_reg set_bin_reg[] = {
+	{MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_WRITE, REG_ROW_ADDRESS_MODE, 0},
+	{MT9P031_TOK_WRITE, REG_COL_ADDRESS_MODE, 0},
+	{MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_TERM, 0, 0}
+};
+static int mt9p031_set_binning(struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+
+	set_bin_reg[1].val = (sensor->row_bin << ROW_BIN_SHIFT)
+			    	| (sensor->row_skip << ROW_SKIP_SHIFT);
+	set_bin_reg[2].val = (sensor->col_bin << COLUMN_BIN_SHIFT)
+			    	| (sensor->col_skip << COLUMN_SKIP_SHIFT);
+
+	/*
+	dev_dbg(&client->dev, 
+		"mt9p031_set_binning() row_mode 0x%04X  col_mode 0x%04X\n",
+		set_bin_reg[1].val, set_bin_reg[2].val);
+	*/
+
+	err = mt9p031_write_regs(client, set_bin_reg);
+	if (err)
+		dev_warn(&client->dev, "Error setting sensor binning\n");
+
+	return err;
+}
+
+#define SENSOR_COL_MIN_OFFSET	16	
+#define SENSOR_COL_MAX_SPAN	2608
+#define SENSOR_ROW_MIN_OFFSET	54	
+#define SENSOR_ROW_MAX_SPAN	1998
+
+struct mt9p031_reg set_window_pos_reg[] = {
+	{MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_WRITE, REG_ROW_START, 0x0036},
+	{MT9P031_TOK_WRITE, REG_COLUMN_START, 0x0010},
+	{MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_TERM, 0, 0}
+};
+static int mt9p031_set_window_pos(struct mt9p031_sensor *sensor, u16 start_row,
+				      u16 start_col)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+
+	if (start_col < SENSOR_COL_MIN_OFFSET)
+		start_col = SENSOR_COL_MIN_OFFSET;
+	else if (start_col + sensor->col_size > SENSOR_COL_MAX_SPAN)
+		start_col = SENSOR_COL_MAX_SPAN - sensor->col_size;
+
+	if (start_row < SENSOR_ROW_MIN_OFFSET)
+		start_row = SENSOR_ROW_MIN_OFFSET;
+	else if (start_row + sensor->row_size > SENSOR_ROW_MAX_SPAN)
+		start_row = SENSOR_ROW_MAX_SPAN - sensor->row_size;
+
+	set_window_pos_reg[1].val = start_row;
+	set_window_pos_reg[2].val = start_col;
+
+	err = mt9p031_write_regs(client, set_window_pos_reg);
+	if(err)
+		return err;
+
+	sensor->row_start = start_row;
+	sensor->col_start = start_col;
+
+	return 0;
+}
+
+struct mt9p031_reg set_window_size_reg[] = {
+	{MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_WRITE, REG_ROW_HEIGHT, 0x0797},
+	{MT9P031_TOK_WRITE, REG_COLUMN_WIDTH, 0x0A1F},
+	{MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_TERM, 0, 0}
+};
+static int mt9p031_set_window_size(struct mt9p031_sensor *sensor, u16 row_size, 
+				   u16 col_size) 
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+
+	//dev_dbg(&client->dev, "mt9p031_set_window_size() %dx%d\n", 
+	//	col_size, row_size);
+
+	set_window_size_reg[1].val = row_size - 1;
+	set_window_size_reg[2].val = col_size - 1;
+
+	err = mt9p031_write_regs(client, set_window_size_reg);
+	if(err)
+		return err;
+
+	sensor->row_size = row_size;
+	sensor->col_size = col_size;
+
+	return 0;
+}
+
+static u16 mt9p031_calc_HBmin(struct mt9p031_sensor *sensor)
+{
+	/* The data sheet says these are the minimum H-blank settings,
+	 * but in practice they appear to be wrong.
+         */
+	 const static u16 HBmin[4][4] = {
+	 	{ 450, 430, 0, 420 },
+	 	{ 796, 776, 0, 766 },
+	 	{ 0, 0, 0, 0 },
+	 	{ 1488, 1468, 0, 1458 }
+	 };
+	 
+	/*
+	 * The settings used here have been experimentally determined to 
+         * be more correct. Going with the data sheet for now.
+	 * const static u16 HBmin[][4] = {
+	 *	{289,269,0,259},
+	 *	{475,455,0,445},
+	 *	{0,0,0,0},
+	 *	{847,827,0,817}
+	 * };
+	 */
+
+	if (sensor->row_bin > 3 || sensor->col_bin > 3)
+		return HBmin[3][3];
+
+	return HBmin[sensor->row_bin][sensor->col_bin];
+}
+
+static u16 mt9p031_calc_VBmin(struct mt9p031_sensor *sensor)
+{
+	u16 ret = 0;
+
+	if (sensor->shutter_width > sensor->pix.height)
+		ret = sensor->shutter_width - sensor->pix.height;
+	
+	ret = ret > 8 ? ret : 8;
+
+	return ret + 1;
+}
+
+struct mt9p031_reg set_blank_reg[] = {
+	{MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_WRITE, REG_HORIZONTAL_BLANK, 0x0},
+	{MT9P031_TOK_WRITE, REG_VERTICAL_BLANK, 0x19},
+	{MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES},
+	{MT9P031_TOK_TERM, 0, 0}
+};
+static int mt9p031_set_blank(u16 hBlank, u16 vBlank,
+			     struct mt9p031_sensor *sensor)
+{
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+
+	dev_dbg(&client->dev, "mt9p031_set_blank(hBlank = %u, vBlank = %u)\n",
+		hBlank, vBlank);	
+
+	set_blank_reg[1].val = hBlank;
+	set_blank_reg[2].val = vBlank - 1;
+
+	err = mt9p031_write_regs(client, set_blank_reg);
+	if (err)
+		return err;
+	
+	sensor->h_blank = hBlank;
+	sensor->v_blank = vBlank;
+
+	return 0;
+}
+
+static unsigned int mt9p031_output_width(struct mt9p031_sensor *sensor)
+{
+	unsigned int out_w;
+
+	out_w = 2 * (sensor->col_skip + 1);
+
+	if (sensor->col_size % out_w)
+		out_w = 2 * (sensor->col_size / out_w) + 1;
+	else
+		out_w = 2 * (sensor->col_size / out_w);
+
+	return out_w;
+}
+
+
+static unsigned int mt9p031_output_height(struct mt9p031_sensor *sensor)
+{
+	unsigned int out_h;
+
+	out_h = 2 * (sensor->row_skip + 1);
+
+	if (sensor->row_size % out_h)
+		out_h = 2 * (sensor->row_size / out_h + 1);
+	else
+		out_h = 2 * (sensor->row_size / out_h);
+
+	return out_h;
+}
+
+static int mt9p031_set_fps(unsigned int fps, struct mt9p031_sensor* sensor)
+{
+	unsigned int out_w, out_h;
+	unsigned int row_clocks, rows_per_sec;
+	int HBmin = mt9p031_calc_HBmin(sensor);
+	int VBmin = mt9p031_calc_VBmin(sensor);
+	int v_blank = 0;
+	int err;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+
+	/*
+	dev_dbg(&client->dev, "start fps = %d\n", sensor->fps);
+	dev_dbg(&client->dev, "HBmin = %d  VBmin = %d\n", HBmin, VBmin);
+	dev_dbg(&client->dev, "requested fps = %u\n", fps);
+	*/
+
+	if (fps < 1 || fps > sensor->max_fps)
+		fps = sensor->max_fps;
+
+	out_w = mt9p031_output_width(sensor);
+	out_h = mt9p031_output_height(sensor);
+
+	//dev_dbg(&client->dev, "out_w = %u  out_h = %u\n", out_w, out_h);
+
+	row_clocks = out_w + (HBmin * 2);
+
+	rows_per_sec = sensor->pixclk / row_clocks;
+
+	if (rows_per_sec > out_h * fps)
+		v_blank = (rows_per_sec - out_h * fps) / fps;
+	else
+		v_blank = VBmin;
+
+	/*
+	dev_dbg(&client->dev, 
+		"row_clocks = %u  rows_per_sec = %u  v_blank = %u\n",
+		row_clocks, rows_per_sec, v_blank);
+	*/
+
+	err = mt9p031_set_blank(HBmin, (u16)v_blank, sensor);
+	if (err) {
+		dev_info(&client->dev, "mt9p031_set_blank() returned %d\n",
+			err);
+
+		return err;
+	}
+
+	sensor->fps = rows_per_sec / (out_h + v_blank);
+
+	dev_dbg(&client->dev, "finish fps = %d\n", sensor->fps);
+
+	return 0;
+}
+
+static unsigned int mt9p031_shutter_overhead(unsigned int row_bin, 
+						unsigned int shutter_width)
+{
+	return 208 * (row_bin + 1) + 98 + (shutter_width + 1) - 94;
+}
+
+static struct mt9p031_reg set_exposure_time[] = {
+	{ MT9P031_TOK_OR, REG_OUTPUT_CONTROL, OUTPUT_CTRL_SYNC_CHANGES },
+	{ MT9P031_TOK_WRITE, REG_SHUTTER_WIDTH_UPPER, 0 },
+	{ MT9P031_TOK_WRITE, REG_SHUTTER_WIDTH_LOWER, 500 },
+	{ MT9P031_TOK_WRITE, REG_SHUTTER_DELAY, 0 },
+	{ MT9P031_TOK_AND, REG_OUTPUT_CONTROL, ~OUTPUT_CTRL_SYNC_CHANGES },
+	{ MT9P031_TOK_TERM, 0, 0 }
+};
+static int mt9p031_set_exposure(unsigned long exp_time, 
+				struct mt9p031_sensor *sensor)
+{	
+	int err;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	unsigned int out_w, out_h;
+	unsigned int shutter_overhead, shutter_width;
+	unsigned int max_shutter_width;
+	unsigned int shutter_delay = 0;
+	unsigned int exp_clk;
+	int remainder;
+	int SD;
+
+	exp_clk = exp_time * (sensor->pixclk / 1000000);
+
+	out_w = mt9p031_output_width(sensor);
+	out_h = mt9p031_output_height(sensor);
+
+	max_shutter_width = out_h + sensor->v_blank - 2;
+
+	sensor->row_clk = out_w + (2 * sensor->h_blank);
+
+	shutter_overhead = mt9p031_shutter_overhead(sensor->row_bin, 
+							shutter_delay);
+	shutter_overhead *= 2;
+
+	shutter_width = (exp_clk + shutter_overhead) / sensor->row_clk;
+
+	if (shutter_width > max_shutter_width) {
+		shutter_width = max_shutter_width;		
+	}
+	else if (shutter_width < 1) {
+		shutter_width = 1;
+	}
+	else {
+		/* using shutter_delay to compensate for SW roundoff error */
+		remainder = exp_clk - (shutter_width * sensor->row_clk) 
+				+ shutter_overhead;
+
+		if (remainder) {
+			SD = (sensor->row_clk - remainder) / 2;
+
+			if (SD > 0) {
+				if (shutter_width < 3 && SD > 1232)
+					SD = 1232;
+				else if (shutter_width >= 3 && SD > 1504)
+					SD = 1504;
+				
+				shutter_delay = SD;
+			}
+
+			shutter_width += 1;
+		}
+	}
+
+	set_exposure_time[1].val = (shutter_width & 0xFFFF0000) >> 16;
+	set_exposure_time[2].val = shutter_width & 0x0000FFFF;
+	set_exposure_time[3].val = shutter_delay & 0x0000FFFF;
+
+	err = mt9p031_write_regs(client, set_exposure_time);
+	if(err)
+		return err;
+
+	sensor->shutter_width = shutter_width;
+	sensor->shutter_delay = shutter_delay;
+
+	shutter_overhead = mt9p031_shutter_overhead(sensor->row_bin,
+							shutter_delay);
+
+	sensor->exposure = ((shutter_width * sensor->row_clk) 
+						- (2 * shutter_overhead))
+ 			/ (sensor->pixclk / 1000000);
+
+	/* don't perpetuate round off errors */
+	if (exp_time > sensor->exposure) {
+		if (exp_time - sensor->exposure < 2)
+			sensor->exposure = exp_time;
+	}
+
+	dev_dbg(&client->dev, "finish exposure = %lu sw = %u sd = %u\n",
+		sensor->exposure, shutter_width, shutter_delay);
+	
+	return 0;
+}
+
+/**
+ * mt9p031_configure - Configure the mt9p031 for the specified image mode
+ * @s: pointer to standard V4L2 device structure
+ */
+static int mt9p031_configure(struct v4l2_int_device *s)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+
+
+	dev_dbg(&client->dev, "mt9p031_configure\n");
+
+	err = mt9p031_write_regs(client, mt9p031_common);
+	if (err)
+		return err;
+
+	err = mt9p031_set_window_size(sensor, sensor->row_size, 
+					sensor->col_size);
+	if (err)
+		return err;
+
+	err = mt9p031_set_window_pos(sensor, sensor->row_start, 
+					sensor->col_start);
+	if (err)
+		return err;
+
+	err = mt9p031_set_binning(sensor);
+	if (err)
+		return err;
+
+	err = mt9p031_set_fps(sensor->fps, sensor);
+	if (err)
+		return err;
+
+	err = mt9p031_set_exposure(sensor->exposure, sensor);
+	if (err)
+		return err;
+
+	err = mt9p031_set_all_gains(sensor);
+	if (err)
+		return err;
+
+	if (test_pattern >= 0) {
+		err = mt9p031_set_test_pattern(sensor, test_pattern);
+		if (err)
+			return err;
+	}
+
+	err = mt9p031_write_regs(client, stream_on_list);
+
+	if (!err) {
+		sensor->streaming = 1;
+
+		if (debug)
+			mt9p031_dump_regs(client);
+	}
+
+	return err;
+}
+
+/**
+ * mt9p031_detect - Detect if an mt9p031 is present, and if so which revision
+ * @client: pointer to the i2c client driver structure
+ */
+static int mt9p031_detect(struct i2c_client *client)
+{
+	u16 chip_version;
+
+	if (!client)
+		return -ENODEV;
+
+	if (mt9p031_read_reg(client, REG_CHIP_VERSION, &chip_version))
+		return -ENODEV;
+
+	dev_info(&client->dev, "chip version detected 0x%x\n", chip_version);
+
+	if (chip_version != MT9P031_CHIP_VERSION) {
+		dev_warn(&client->dev, "chip version mismatch 0x%x \n",
+			chip_version);
+
+		return -ENODEV;
+	}
+
+
+	return chip_version;
+}
+
+
+/**
+ * ioctl_queryctrl - V4L2 sensor interface handler for VIDIOC_QUERYCTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @qc: standard V4L2 VIDIOC_QUERYCTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control information
+ * from the video_control[] array.  Otherwise, returns -EINVAL if the
+ * control is not supported.
+ */
+static int ioctl_queryctrl(struct v4l2_int_device *s, struct v4l2_queryctrl *vc)
+{
+        int i;
+
+        if (vc->id & V4L2_CTRL_FLAG_NEXT_CTRL) {
+                vc->id &= ~V4L2_CTRL_FLAG_NEXT_CTRL;
+
+                for (i = 0; i < ARRAY_SIZE(mt9p031_ctrl); i++) {
+                        if (mt9p031_ctrl[i].id > vc->id) {
+                                *vc = mt9p031_ctrl[i];
+                                return 0;
+                        }
+                }
+        }
+        else {
+                for (i = 0; i < ARRAY_SIZE(mt9p031_ctrl); i++) {
+                        if (vc->id == mt9p031_ctrl[i].id) {
+                                *vc = mt9p031_ctrl[i];
+                                return 0;
+                        }
+                }
+        }
+
+        vc->flags = V4L2_CTRL_FLAG_DISABLED;
+        return -EINVAL;
+}
+
+/**
+ * ioctl_g_ctrl - V4L2 sensor interface handler for VIDIOC_G_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_G_CTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control's current
+ * value from the video_control[] array.  Otherwise, returns -EINVAL
+ * if the control is not supported.
+ */
+static int ioctl_g_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+
+	switch (vc->id) {
+	case  V4L2_CID_EXPOSURE:
+		vc->value = sensor->exposure;
+		break;
+
+	case V4L2_CID_GAIN:
+		// makes no sense on its own, just return green1
+		// deliberate fall through
+	case V4L2_MT9P031_GREEN1_GAIN:		
+		vc->value = sensor->green1_gain;
+		break;
+
+	case V4L2_MT9P031_BLUE_GAIN:		
+		vc->value = sensor->blue_gain;
+		break;
+
+	case V4L2_MT9P031_RED_GAIN:		
+		vc->value = sensor->red_gain;
+		break;
+
+	case V4L2_MT9P031_GREEN2_GAIN:		
+		vc->value = sensor->green2_gain;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * ioctl_s_ctrl - V4L2 sensor interface handler for VIDIOC_S_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
+ *
+ * If the requested control is supported, sets the control's current
+ * value in HW (and updates the video_control[] array).  Otherwise,
+ * returns -EINVAL if the control is not supported.
+ */
+static int ioctl_s_ctrl(struct v4l2_int_device *s, struct v4l2_control *vc)
+{
+	int ret = 0;
+	struct mt9p031_sensor *sensor = s->priv;
+
+	switch (vc->id) {
+	case V4L2_CID_EXPOSURE:
+		if (sensor->streaming) {
+			ret = mt9p031_set_exposure(vc->value, sensor);
+			vc->value = sensor->exposure;
+		}
+		else {
+			sensor->exposure = vc->value;
+		}
+
+		break;
+
+	case V4L2_CID_GAIN:
+		if (sensor->streaming) {
+			ret = mt9p031_set_global_gain(sensor, vc->value);
+			vc->value = sensor->green1_gain;
+		}
+		else {
+			sensor->green1_gain = vc->value;
+			sensor->blue_gain = vc->value;		
+			sensor->red_gain = vc->value;
+			sensor->green2_gain = vc->value;
+		}
+
+		break;
+
+	case V4L2_MT9P031_GREEN1_GAIN:
+		if (sensor->streaming) {
+			ret = mt9p031_set_green1_gain(sensor, vc->value);
+			vc->value = sensor->green1_gain;
+		}
+		else {
+			sensor->green1_gain = vc->value;
+		}
+
+		break;
+
+	case V4L2_MT9P031_BLUE_GAIN:
+		if (sensor->streaming) {
+			ret = mt9p031_set_blue_gain(sensor, vc->value);
+			vc->value = sensor->blue_gain;		
+		}
+		else {
+			sensor->blue_gain = vc->value;
+		}
+
+		break;
+
+	case V4L2_MT9P031_RED_GAIN:
+		if (sensor->streaming) {
+			ret = mt9p031_set_red_gain(sensor, vc->value);
+			vc->value = sensor->red_gain;
+		}
+		else {
+			sensor->red_gain = vc->value;
+		}
+
+		break;
+
+	case V4L2_MT9P031_GREEN2_GAIN:
+		if (sensor->streaming) {
+			ret = mt9p031_set_green2_gain(sensor, vc->value);
+			vc->value = sensor->green2_gain;
+		}
+		else {
+			sensor->green2_gain = vc->value;
+		}
+
+		break;
+
+ 	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/**
+ * ioctl_enum_fmt_cap - Implement the CAPTURE buffer VIDIOC_ENUM_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fmt: standard V4L2 VIDIOC_ENUM_FMT ioctl structure
+ *
+ * Implement the VIDIOC_ENUM_FMT ioctl for the CAPTURE buffer type.
+ */
+static int ioctl_enum_fmt_cap(struct v4l2_int_device *s,
+			      struct v4l2_fmtdesc *fmt)
+{
+	if (fmt->type != mt9p031_format.type || fmt->index > 0)
+		return -EINVAL;
+
+	fmt->flags = mt9p031_format.flags;
+	fmt->pixelformat = mt9p031_format.pixelformat;
+
+	strlcpy(fmt->description, mt9p031_format.description,
+		sizeof(fmt->description));
+
+	return 0;
+}
+
+/**
+ * ioctl_try_fmt_cap - Implement the CAPTURE buffer VIDIOC_TRY_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_TRY_FMT ioctl structure
+ *
+ * Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type.  This
+ * ioctl is used to negotiate the image capture size and pixel format
+ * without actually making it take effect.
+ *
+ */
+static int ioctl_try_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	if (f->type != mt9p031_format.type)
+		return -EINVAL;
+
+	pix->width = sensor->pix.width;
+	pix->height = sensor->pix.height;
+	pix->pixelformat = mt9p031_format.pixelformat;
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = pix->width * 2;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->priv = 0;
+	pix->colorspace = V4L2_COLORSPACE_SRGB;
+
+	return 0;
+}
+
+/**
+ * ioctl_s_fmt_cap - V4L2 sensor interface handler for VIDIOC_S_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_S_FMT ioctl structure
+ *
+ * If the requested format is supported, configures the HW to use that
+ * format, returns error code if format not supported or HW can't be
+ * correctly configured.
+ *
+ * This function is going to configure the ISP LV and FV registers.
+ */
+static int ioctl_s_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	int rval;
+
+	rval = ioctl_try_fmt_cap(s, f);
+	if (!rval)
+		sensor->pix = f->fmt.pix;
+
+	return rval;
+}
+
+/**
+ * ioctl_g_fmt_cap - V4L2 sensor interface handler for ioctl_g_fmt_cap
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 v4l2_format structure
+ *
+ * Returns the sensor's current pixel format in the v4l2_format
+ * parameter.
+ */
+static int ioctl_g_fmt_cap(struct v4l2_int_device *s, struct v4l2_format *f)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	f->fmt.pix = sensor->pix;
+
+	return 0;
+}
+
+/**
+ * ioctl_g_parm - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the sensor's video CAPTURE parameters.
+ */
+static int ioctl_g_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(a, 0, sizeof(*a));
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	cparm->capability = V4L2_CAP_TIMEPERFRAME;
+	cparm->timeperframe.numerator = 1;
+	cparm->timeperframe.denominator = sensor->fps;
+
+	return 0;
+}
+
+/**
+ * ioctl_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the sensor to use the input parameters, if possible.  If
+ * not possible, reverts to the old parameters and returns the
+ * appropriate error code.
+ */
+static int ioctl_s_parm(struct v4l2_int_device *s, struct v4l2_streamparm *a)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+
+	if (timeperframe->numerator == 0 || timeperframe->denominator == 0) {
+		sensor->fps = sensor->max_fps;
+	}
+	else {
+		sensor->fps = timeperframe->denominator 
+					/ timeperframe->numerator;
+
+		if (sensor->fps > sensor->max_fps)
+			sensor->fps = sensor->max_fps;
+		else if (sensor->fps < 1)
+			sensor->fps = 1;
+	}
+
+	timeperframe->numerator = 1;
+	timeperframe->denominator = sensor->fps;
+
+	return 0;
+}
+
+/**
+ * ioctl_g_priv - V4L2 sensor interface handler for vidioc_int_g_priv_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: void pointer to hold sensor's private data address
+ *
+ * Returns device's (sensor's) private data area address in p parameter
+ */
+static int ioctl_g_priv(struct v4l2_int_device *s, void *p)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+
+	return sensor->pdata->priv_data_set(p);
+}
+
+/**
+ * ioctl_enum_framesizes - V4L2 sensor if handler for vidioc_int_enum_framesizes
+ * @s: pointer to standard V4L2 device structure
+ * @frms: pointer to standard V4L2 framesizes enumeration structure
+ *
+ * Returns possible framesizes depending on choosen pixel format
+ **/
+static int ioctl_enum_framesizes(struct v4l2_int_device *s,
+				 struct v4l2_frmsizeenum *frms)
+{
+	if (frms->pixel_format != mt9p031_format.pixelformat)
+		return -EINVAL;
+
+	if (frms->index >= ARRAY_SIZE(mt9p031_sizes))
+		return -EINVAL;
+
+	frms->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	frms->discrete.width = mt9p031_sizes[frms->index].width;
+	frms->discrete.height = mt9p031_sizes[frms->index].height;
+
+	return 0;
+}
+
+static int ioctl_enum_frameintervals(struct v4l2_int_device *s,
+				     struct v4l2_frmivalenum *frmi)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+
+	if (frmi->pixel_format != mt9p031_format.pixelformat)
+		return -EINVAL;
+
+	if (frmi->index >= sensor->max_fps)
+		return -EINVAL;
+
+	frmi->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	frmi->discrete.numerator = 1;
+	frmi->discrete.denominator = frmi->index + 1;
+
+	return 0;
+}
+
+static int mt9p031_power_off(struct v4l2_int_device *s)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+
+	return sensor->pdata->power_set(s, V4L2_POWER_OFF);
+}
+
+static int mt9p031_power_standby(struct v4l2_int_device *s)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+
+	return sensor->pdata->power_set(s, V4L2_POWER_STANDBY);
+}
+
+static int mt9p031_power_on(struct v4l2_int_device *s)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+
+	return sensor->pdata->power_set(s, V4L2_POWER_ON);
+}
+
+/**
+ * ioctl_init - V4L2 sensor interface handler for VIDIOC_INT_INIT
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialize the sensor device (call mt9p031_configure())
+ */
+static int ioctl_init(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_exit - V4L2 sensor interface handler for vidioc_int_dev_exit_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Delinitialise the dev. at slave detach.  The complement of ioctl_dev_init.
+ */
+static int ioctl_dev_exit(struct v4l2_int_device *s)
+{
+	return 0;
+}
+
+/**
+ * ioctl_dev_init - V4L2 sensor interface handler for vidioc_int_dev_init_num
+ * @s: pointer to standard V4L2 device structure
+ *
+ * Initialise the device when slave attaches to the master.  Returns 0 if
+ * mt9p031 device could be found, otherwise returns appropriate error.
+ */
+static int ioctl_dev_init(struct v4l2_int_device *s)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int err;
+	
+	//dev_dbg(&client->dev, "ioctl_dev_init()\n");
+
+	err = mt9p031_detect(client);
+	if (err < 0) {
+		sensor->xclk_current = MT9P031_DEFAULT_XCLK;
+		err = mt9p031_detect(client);
+		if (err < 0) {
+			sensor->detected = 0;
+			dev_err(&client->dev, "Unable to detect sensor\n");
+			return err;
+		}
+		sensor->detected = 1;
+		sensor->ver = err;
+		sensor->pll.use_pll = 0;
+		sensor->pixclk = sensor->xclk_current;
+		sensor->pll.use_extclk = 1;
+		dev_info(&client->dev, "using OMAP clock\n");
+	}
+	else {
+		//dev_dbg(&client->dev, "using onboard oscillator\n");
+		sensor->xclk_current = MT9P031_DEFAULT_XCLK;
+		sensor->detected = 1;
+		sensor->ver = err;
+		sensor->pll.use_pll = 1;
+		sensor->pll.use_extclk = 0;
+	
+		if (pixel_clock >= 48000000) {
+			// For 48 MHz clock
+			sensor->pll.pll_m_factor = 24;
+			sensor->pll.pll_n_divider = 2;
+			sensor->pll.pll_p1_divider = 6;
+		}
+		else {
+			// For 24 MHz clock
+			sensor->pll.pll_m_factor = 30;
+			sensor->pll.pll_n_divider = 3;
+			sensor->pll.pll_p1_divider = 10;
+		}
+
+		err = mt9p031_set_pll(&sensor->pll, sensor);		
+	}
+
+	err = mt9p031_power_off(s);
+	if (err)
+		return -ENODEV;
+
+	return 0;
+}
+
+/**
+ * ioctl_s_power - V4L2 sensor interface handler for vidioc_int_s_power_num
+ * @s: pointer to standard V4L2 device structure
+ * @on: power state to which device is to be set
+ *
+ * Sets device power to requested state, if possible.
+ */
+static int ioctl_s_power(struct v4l2_int_device *s, enum v4l2_power new_power)
+{
+	struct mt9p031_sensor *sensor = s->priv;
+	struct i2c_client *client = to_i2c_client(sensor->dev);
+	int rval = 0;
+
+	switch (new_power) {
+	case V4L2_POWER_ON:
+		dev_dbg(&client->dev, "ioctl_s_power(V4L2_POWER_ON)\n");
+		rval = mt9p031_power_on(s);
+		if (rval)
+			break;
+
+		if (sensor->detected) {
+			mt9p031_configure(s);
+		}
+		else {
+			rval = ioctl_dev_init(s);
+			if (rval) {
+				dev_err(&client->dev, 
+					"ioctl_dev_init() failed\n");
+				mt9p031_power_off(s);
+			}
+		}
+
+		break;
+
+	case V4L2_POWER_OFF:
+		dev_dbg(&client->dev, "ioctl_s_power(V4L2_POWER_OFF)\n");
+		rval = mt9p031_power_off(s);
+		sensor->streaming = 0;
+		break;
+
+	case V4L2_POWER_STANDBY:
+		dev_dbg(&client->dev, "ioctl_s_power(V4L2_POWER_STANDBY)\n");
+		mt9p031_write_regs(client, stream_off_list);
+		rval = mt9p031_power_standby(s);
+		sensor->streaming = 0;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return rval;
+}
+
+static struct v4l2_int_ioctl_desc mt9p031_ioctl_desc[] = {
+	{ .num = vidioc_int_enum_framesizes_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_enum_framesizes },
+	{ .num = vidioc_int_enum_frameintervals_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_enum_frameintervals },
+	{ .num = vidioc_int_dev_init_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_dev_init },
+	{ .num = vidioc_int_dev_exit_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_dev_exit },
+	{ .num = vidioc_int_s_power_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_s_power },
+	{ .num = vidioc_int_g_priv_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_g_priv },
+	{ .num = vidioc_int_init_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_init },
+	{ .num = vidioc_int_enum_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_enum_fmt_cap },
+	{ .num = vidioc_int_try_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_try_fmt_cap },
+	{ .num = vidioc_int_g_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_g_fmt_cap },
+	{ .num = vidioc_int_s_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_s_fmt_cap },
+	{ .num = vidioc_int_g_parm_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_g_parm },
+	{ .num = vidioc_int_s_parm_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_s_parm },
+	{ .num = vidioc_int_queryctrl_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_queryctrl },
+	{ .num = vidioc_int_g_ctrl_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_g_ctrl },
+	{ .num = vidioc_int_s_ctrl_num,
+	  .func = (v4l2_int_ioctl_func *)ioctl_s_ctrl },
+};
+
+static struct v4l2_int_slave mt9p031_slave = {
+	.ioctls = mt9p031_ioctl_desc,
+	.num_ioctls = ARRAY_SIZE(mt9p031_ioctl_desc),
+};
+
+static struct v4l2_int_device mt9p031_int_device = {
+	.module = THIS_MODULE,
+	.name = DRIVER_NAME,
+	.type = v4l2_int_type_slave,
+	.u = {
+		.slave = &mt9p031_slave,
+	},
+};
+
+/**
+ * mt9p031_probe - sensor driver i2c probe handler
+ * @client: i2c driver client device structure
+ *
+ * Register sensor as an i2c client device and V4L2 device.
+ */
+static int mt9p031_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct mt9p031_sensor *sensor;
+	struct mt9p031_platform_data *pdata;
+	int err;
+
+	dev_info(&client->dev, "mt9p031_i2c_probe()\n");
+	
+	if (i2c_get_clientdata(client))
+		return -EBUSY;
+
+	pdata = client->dev.platform_data;
+	if (!pdata) {
+		dev_err(&client->dev, "no platform data?\n");
+		return -EINVAL;
+	}
+
+	sensor = kzalloc(sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	/* Don't keep pointer to platform data, copy elements instead */
+	sensor->pdata = kzalloc(sizeof(*sensor->pdata), GFP_KERNEL);
+	if (!sensor->pdata) {
+		err = -ENOMEM;
+		goto on_err1;
+	}
+
+	sensor->pdata->power_set = pdata->power_set;
+	sensor->pdata->priv_data_set = pdata->priv_data_set;
+
+	sensor->xclk_current = 0;
+	sensor->pll.use_pll = 0;
+	sensor->pll.use_extclk = 1;
+	sensor->output_size = MT9P031_2560X1920;
+	sensor->pix.width = mt9p031_sizes[MT9P031_2560X1920].width;
+	sensor->pix.height = mt9p031_sizes[MT9P031_2560X1920].height;
+	sensor->pix.pixelformat = mt9p031_format.pixelformat;
+	
+	sensor->pixclk = MT9P031_DEFAULT_PIXCLK;
+	sensor->col_start = MT9P031_DEFAULT_COL_START;
+	sensor->row_start = MT9P031_DEFAULT_ROW_START;
+	sensor->col_size = MT9P031_DEFAULT_COL_SIZE;
+	sensor->row_size = MT9P031_DEFAULT_ROW_SIZE;
+	sensor->col_skip = 0; 
+	sensor->col_bin = 0;
+	sensor->row_skip = 0;
+	sensor->row_bin = 0;
+	sensor->shutter_width = 139;
+	sensor->shutter_delay = 257;
+	sensor->detected = 0;
+
+	if (pixel_clock < 48000000)
+		sensor->max_fps = 3;
+	else
+		sensor->max_fps = 7;
+
+	sensor->fps = sensor->max_fps;
+	sensor->exposure = MT9P031_DEF_EXPOSURE;
+	sensor->green1_gain = 1;
+	sensor->blue_gain = 1;
+	sensor->red_gain = 1;
+	sensor->green2_gain = 1;
+	sensor->v4l2_int_device = &mt9p031_int_device;
+	sensor->v4l2_int_device->priv = sensor;
+	sensor->dev = &client->dev;
+	i2c_set_clientdata(client, sensor);
+
+	err = v4l2_int_device_register(sensor->v4l2_int_device);
+	if (err) {
+		goto on_err2;
+	}
+
+	//dev_info(&client->dev, "leaving mt9p031_i2c_probe() success\n");
+
+	return 0;
+on_err2:
+	i2c_set_clientdata(client, NULL);
+	kfree(sensor->pdata);
+on_err1:
+	kfree(sensor);
+	return err;
+}
+
+/**
+ * mt9p031_remove - sensor driver i2c remove handler
+ * @client: i2c driver client device structure
+ *
+ * Unregister sensor as an i2c client device and V4L2 device.  
+ * Complement of mt9p031_probe().
+ */
+static int mt9p031_remove(struct i2c_client *client)
+{
+	struct mt9p031_sensor *sensor = i2c_get_clientdata(client);
+
+	v4l2_int_device_unregister(sensor->v4l2_int_device);
+	i2c_set_clientdata(client, NULL);
+	kfree(sensor->pdata);
+	kfree(sensor);
+
+	return 0;
+}
+
+static const struct i2c_device_id mt9p031_id[] = {
+	{ DRIVER_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, mt9p031_id);
+
+static struct i2c_driver mt9p031_i2c_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = mt9p031_probe,
+	.remove = mt9p031_remove,
+	.id_table = mt9p031_id,
+};
+
+/**
+ * mt9p031sensor_init - sensor driver module_init handler
+ *
+ * Registers driver as an i2c client driver.
+ */
+static int __init mt9p031_init(void)
+{
+	return i2c_add_driver(&mt9p031_i2c_driver);
+}
+module_init(mt9p031_init);
+
+/**
+ * mt9p031sensor_cleanup - sensor driver module_exit handler
+ *
+ * Unregisters/deletes driver as an i2c client driver.
+ */
+static void __exit mt9p031_cleanup(void)
+{
+	i2c_del_driver(&mt9p031_i2c_driver);
+}
+module_exit(mt9p031_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("mt9p031 camera sensor driver");
diff --git git/drivers/media/video/mt9p031_regs.h git/drivers/media/video/mt9p031_regs.h
new file mode 100644
index 0000000..0428672
--- /dev/null
+++ git/drivers/media/video/mt9p031_regs.h
@@ -0,0 +1,86 @@
+#ifndef __VIDEO_MT9P031_REGS_H
+#define __VIDEO_MT9P031_REGS_H
+
+
+/* mt9p031 selected register addresses */
+#define REG_CHIP_VERSION		0x00
+#define REG_ROW_START			0x01
+#define REG_COLUMN_START		0x02
+#define REG_ROW_HEIGHT			0x03
+#define REG_COLUMN_WIDTH		0x04
+#define REG_HORIZONTAL_BLANK		0x05
+#define REG_VERTICAL_BLANK		0x06
+#define REG_OUTPUT_CONTROL		0x07
+#define REG_SHUTTER_WIDTH_UPPER		0x08
+#define REG_SHUTTER_WIDTH_LOWER		0x09
+#define REG_PIXEL_CLOCK_CONTROL		0x0a
+#define REG_FRAME_RESTART		0x0b
+#define REG_SHUTTER_DELAY		0x0c
+#define REG_RESET			0x0d
+#define REG_PLL_CONTROL			0x10
+#define REG_PLL_CONFIG1			0x11
+#define REG_PLL_CONFIG2			0x12
+#define REG_READ_MODE1			0x1e
+#define REG_READ_MODE2			0x20
+#define REG_ROW_ADDRESS_MODE	        0x22
+#define REG_COL_ADDRESS_MODE	        0x23
+#define REG_RESERVED_27_REG		0x27
+#define REG_GREEN1_GAIN			0x2B
+#define REG_BLUE_GAIN			0x2C
+#define REG_RED_GAIN			0x2D
+#define REG_GREEN2_GAIN			0x2E
+#define REG_RESERVED_30_REG		0x30
+#define REG_GLOBAL_GAIN			0x35
+#define REG_BLACK_LEVEL			0x49
+#define REG_ROW_BLK_DEF_OFFSET		0x4B
+#define REG_RESERVED_4E_REG		0x4E
+#define REG_RESERVED_50_REG         	0x50
+#define REG_RESERVED_51_REG         	0x51
+#define REG_RESERVED_52_REG         	0x52
+#define REG_RESERVED_53_REG         	0x53
+#define REG_CAL_COARSE              	0x5D
+#define REG_CAL_TARGET              	0x5F
+#define REG_GREEN1_OFFSET           	0x60
+#define REG_GREEN2_OFFSET           	0x61
+#define REG_BLK_LVL_CALIB           	0x62
+#define REG_RED_OFFSET              	0x63
+#define REG_BLUE_OFFSET             	0x64
+#define REG_TEST_PATTERN_CONTROL	0xA0
+#define REG_TEST_PATTERN_GREEN		0xA1
+#define REG_TEST_PATTERN_RED		0xA2
+#define REG_TEST_PATTERN_BLUE		0xA3
+#define REG_TEST_PATTERN_BAR_WIDTH	0xA4
+#define REG_CHIP_ENABLE_SYNC        	0xF8
+#define REG_CHIP_VERSION_ALT        	0xFF
+
+#define OUTPUT_CTRL_CHIP_ENABLE		0x0002
+#define OUTPUT_CTRL_SYNC_CHANGES	0x0001
+
+#define PAUSE_RESTART			0x0002
+#define RESTART_FRAME			0x0001
+
+#define DIGITAL_GAIN_SHIFT		8
+#define DIGITAL_GAIN_MASK		0x7F00
+#define ANALOG_MULTIPLIER_SHIFT		6
+#define ANALOG_MULTIPLIER_MASK		0x0040
+#define ANALOG_GAIN_SHIFT		0
+#define ANALOG_GAIN_MASK		0x003F
+
+#define PLL_M_FACTOR_SHIFT		8
+#define PLL_M_FACTOR_MASK		0xFF00
+#define PLL_N_DIVIDER_SHIFT		0
+#define PLL_N_DIVIDER_MASK		0x003F
+#define PLL_P1_DIVIDER_MASK		0x001F
+#define PLL_CTRL_USE_PLL		0x0002
+#define PLL_CTRL_POWER_PLL		0x0001
+
+#define ROW_BIN_SHIFT			4
+#define ROW_BIN_MASK			0x0030
+#define ROW_SKIP_SHIFT			0
+#define ROW_SKIP_MASK			0x0007
+#define COLUMN_BIN_SHIFT		4
+#define COLUMN_BIN_MASK			0x0030
+#define COLUMN_SKIP_SHIFT		0
+#define COLUMN_SKIP_MASK		0x0007
+
+#endif /* __VIDEO_MT9P031_REGS_H */
diff --git git/include/media/mt9p031.h git/include/media/mt9p031.h
new file mode 100644
index 0000000..88c8808
--- /dev/null
+++ git/include/media/mt9p031.h
@@ -0,0 +1,64 @@
+/*
+ * mt9p031.h - Register definitions for the MT9P031 camera sensor.
+ *
+  * Originally based on code from Procerus Technologies
+ * http://gitorious.org/procerus-vpu-main-linux-kernel
+ *
+ * Copyright (C) 2010 Procerus Technologies.
+ *
+ * Contributors:
+ * 	Evan Andersen <evana@procerus.com>
+ * 	Neil Johnson <neilj@procerus.com>
+ *
+ * Modifications:
+ *	Scott Ellis <scott@jumpnowtek.com>
+ *
+ * Heavily modified for a custom board with a max pixel_clock of 48 MHz due
+ * to power supplies. Only 2560x1920 images are supported. The pixel_clock 
+ * speed and image size restrict max frame rate to 7 fps. You can resize the 
+ * images down to 1280x960 or 640x480 using the OMAP ISP resizer via the
+ * V4L2 interface.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef MT9P031_H
+#define MT9P031_H
+
+#include <media/v4l2-int-device.h>
+
+#define MT9P031_CLK_MIN			24000000
+#define MT9P031_CLK_MAX			48000000
+
+
+#define V4L2_MT9P031_GREEN1_GAIN		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_MT9P031_BLUE_GAIN			(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_MT9P031_RED_GAIN			(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_MT9P031_GREEN2_GAIN		(V4L2_CID_PRIVATE_BASE + 3)
+
+
+enum mt9p031_image_size {
+//	MT9P031_640X480,
+//	MT9P031_1280X960,
+	MT9P031_2560X1920,
+//	MT9P031_2592X1944,
+	MT9P031_NUM_IMAGE_SIZES
+};
+
+
+/**
+ * struct mt9p031_platform_data - platform data values and access functions
+ * @power_set: Power state access function, zero is off, non-zero is on.
+ * @ifparm: Interface parameters access function
+ * @priv_data_set: device private data (pointer) access function
+ */
+struct mt9p031_platform_data {
+	char *master;
+	int (*power_set)(struct v4l2_int_device *s, enum v4l2_power power);
+	int (*ifparm) (struct v4l2_ifparm *p);
+	int (*priv_data_set)(void *);
+};
+
+#endif /* ifndef MT9P031_H */
